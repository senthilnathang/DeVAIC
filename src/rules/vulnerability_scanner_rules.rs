use crate::{
    error::Result,
    parsers::{ParsedAst, SourceFile},
    rules::{create_vulnerability, RuleSet},
    Severity, Vulnerability,
};
use regex::Regex;

pub struct VulnerabilityScannerRules {
    cwe_patterns: Vec<VulnerabilityPattern>,
    owasp_patterns: Vec<VulnerabilityPattern>,
    language_specific_patterns: Vec<VulnerabilityPattern>,
}

#[derive(Clone)]
struct VulnerabilityPattern {
    id: String,
    name: String,
    pattern: Regex,
    category: String,
    severity: Severity,
    description: String,
    recommendation: String,
    cwe: String,
    owasp_category: String,
    languages: Vec<String>,
}

impl VulnerabilityScannerRules {
    pub fn new() -> Self {
        let mut cwe_patterns = Vec::new();
        let mut owasp_patterns = Vec::new();
        let mut language_specific_patterns = Vec::new();

        // CWE Top 25 Patterns
        cwe_patterns.extend(vec![
            VulnerabilityPattern {
                id: "cwe-79-xss".to_string(),
                name: "Cross-site Scripting (XSS)".to_string(),
                pattern: Regex::new(r"(?i)(innerHTML|outerHTML|document\.write)\s*[=+]\s*.*(\+|concat)").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::High,
                description: "Potential XSS vulnerability through DOM manipulation".to_string(),
                recommendation: "Use safe DOM manipulation methods or sanitize user input".to_string(),
                cwe: "CWE-79".to_string(),
                owasp_category: "A03:2021 – Injection".to_string(),
                languages: vec!["javascript".to_string(), "typescript".to_string()],
            },
            VulnerabilityPattern {
                id: "cwe-89-sql-injection".to_string(),
                name: "SQL Injection".to_string(),
                pattern: Regex::new(r"(?i)(select|insert|update|delete|drop)\s+.*\$\{.*\}").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::Critical,
                description: "SQL injection vulnerability through string interpolation".to_string(),
                recommendation: "Use parameterized queries or prepared statements".to_string(),
                cwe: "CWE-89".to_string(),
                owasp_category: "A03:2021 – Injection".to_string(),
                languages: vec!["python".to_string(), "java".to_string(), "javascript".to_string(), "c".to_string()],
            },
            VulnerabilityPattern {
                id: "cwe-78-command-injection".to_string(),
                name: "OS Command Injection".to_string(),
                pattern: Regex::new(r"(?i)(system|exec|popen|subprocess\.call)\s*\(\s*[^)]*\$\{").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::Critical,
                description: "OS command injection vulnerability".to_string(),
                recommendation: "Validate input and use subprocess with shell=False in Python".to_string(),
                cwe: "CWE-78".to_string(),
                owasp_category: "A03:2021 – Injection".to_string(),
                languages: vec!["python".to_string(), "java".to_string(), "c".to_string()],
            },
            VulnerabilityPattern {
                id: "cwe-22-path-traversal".to_string(),
                name: "Path Traversal".to_string(),
                pattern: Regex::new(r"(?i)(file|path|url).*\.\./").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::High,
                description: "Path traversal vulnerability detected".to_string(),
                recommendation: "Validate and canonicalize file paths, use whitelist approach".to_string(),
                cwe: "CWE-22".to_string(),
                owasp_category: "A01:2021 – Broken Access Control".to_string(),
                languages: vec!["python".to_string(), "java".to_string(), "javascript".to_string(), "c".to_string()],
            },
            VulnerabilityPattern {
                id: "cwe-125-buffer-overflow".to_string(),
                name: "Buffer Overflow".to_string(),
                pattern: Regex::new(r"(?i)(strcpy|strcat|sprintf|gets)\s*\(").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::Critical,
                description: "Buffer overflow vulnerability from unsafe function usage".to_string(),
                recommendation: "Use safe alternatives: strncpy, strncat, snprintf, fgets".to_string(),
                cwe: "CWE-125".to_string(),
                owasp_category: "A06:2021 – Vulnerable and Outdated Components".to_string(),
                languages: vec!["c".to_string(), "cpp".to_string()],
            },
        ]);

        // OWASP Top 10 Patterns
        owasp_patterns.extend(vec![
            VulnerabilityPattern {
                id: "owasp-a01-broken-access-control".to_string(),
                name: "Broken Access Control".to_string(),
                pattern: Regex::new(r"(?i)(user|admin|role).*=.*request\.(params|query|body)").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::High,
                description: "Potential broken access control - user role from request data".to_string(),
                recommendation: "Validate user permissions server-side, don't trust client data".to_string(),
                cwe: "CWE-284".to_string(),
                owasp_category: "A01:2021 – Broken Access Control".to_string(),
                languages: vec!["javascript".to_string(), "python".to_string(), "java".to_string()],
            },
            VulnerabilityPattern {
                id: "owasp-a02-crypto-failures".to_string(),
                name: "Cryptographic Failures".to_string(),
                pattern: Regex::new(r"(?i)(aes|des|3des|rc4).*ecb").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::High,
                description: "Weak encryption mode (ECB) detected".to_string(),
                recommendation: "Use secure encryption modes like CBC, GCM, or CTR".to_string(),
                cwe: "CWE-327".to_string(),
                owasp_category: "A02:2021 – Cryptographic Failures".to_string(),
                languages: vec!["python".to_string(), "java".to_string(), "javascript".to_string()],
            },
            VulnerabilityPattern {
                id: "owasp-a04-insecure-design".to_string(),
                name: "Insecure Design".to_string(),
                pattern: Regex::new(r#"(?i)(password|secret).*==.*"""#).unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::Medium,
                description: "Empty password or secret comparison detected".to_string(),
                recommendation: "Implement proper authentication and never use empty passwords".to_string(),
                cwe: "CWE-521".to_string(),
                owasp_category: "A04:2021 – Insecure Design".to_string(),
                languages: vec!["python".to_string(), "java".to_string(), "javascript".to_string()],
            },
            VulnerabilityPattern {
                id: "owasp-a05-security-misconfiguration".to_string(),
                name: "Security Misconfiguration".to_string(),
                pattern: Regex::new(r"(?i)(ssl|tls).*verify.*false").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::High,
                description: "SSL/TLS certificate verification disabled".to_string(),
                recommendation: "Enable SSL/TLS certificate verification in production".to_string(),
                cwe: "CWE-295".to_string(),
                owasp_category: "A05:2021 – Security Misconfiguration".to_string(),
                languages: vec!["python".to_string(), "java".to_string(), "javascript".to_string()],
            },
            VulnerabilityPattern {
                id: "owasp-a06-vulnerable-components".to_string(),
                name: "Vulnerable and Outdated Components".to_string(),
                pattern: Regex::new(r"(?i)import.*requests.*2\.[0-9]\.[0-9]").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::Medium,
                description: "Potentially outdated library version detected".to_string(),
                recommendation: "Update to latest secure versions of dependencies".to_string(),
                cwe: "CWE-1104".to_string(),
                owasp_category: "A06:2021 – Vulnerable and Outdated Components".to_string(),
                languages: vec!["python".to_string()],
            },
            VulnerabilityPattern {
                id: "owasp-a08-integrity-failures".to_string(),
                name: "Software and Data Integrity Failures".to_string(),
                pattern: Regex::new(r"(?i)(pickle\.loads|yaml\.load|eval|exec).*input").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::Critical,
                description: "Unsafe deserialization of user input detected".to_string(),
                recommendation: "Use safe deserialization methods and validate input".to_string(),
                cwe: "CWE-502".to_string(),
                owasp_category: "A08:2021 – Software and Data Integrity Failures".to_string(),
                languages: vec!["python".to_string(), "java".to_string()],
            },
        ]);

        // Language-specific patterns
        language_specific_patterns.extend(vec![
            // Python-specific
            VulnerabilityPattern {
                id: "python-import-injection".to_string(),
                name: "Python Import Injection".to_string(),
                pattern: Regex::new(r"(?i)__import__.*input").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::Critical,
                description: "Dynamic import with user input detected".to_string(),
                recommendation: "Avoid dynamic imports with user input, use whitelist approach".to_string(),
                cwe: "CWE-94".to_string(),
                owasp_category: "A03:2021 – Injection".to_string(),
                languages: vec!["python".to_string()],
            },
            // JavaScript-specific
            VulnerabilityPattern {
                id: "javascript-prototype-pollution".to_string(),
                name: "Prototype Pollution".to_string(),
                pattern: Regex::new(r"(?i)(__proto__|constructor\.prototype)").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::High,
                description: "Potential prototype pollution vulnerability".to_string(),
                recommendation: "Validate object properties and use Object.freeze() or Map".to_string(),
                cwe: "CWE-1321".to_string(),
                owasp_category: "A08:2021 – Software and Data Integrity Failures".to_string(),
                languages: vec!["javascript".to_string(), "typescript".to_string()],
            },
            // Java-specific
            VulnerabilityPattern {
                id: "java-xxe-vulnerability".to_string(),
                name: "XML External Entity (XXE)".to_string(),
                pattern: Regex::new(r"(?i)DocumentBuilderFactory.*newInstance").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::High,
                description: "Potential XXE vulnerability in XML parsing".to_string(),
                recommendation: "Disable external entities in XML parsers".to_string(),
                cwe: "CWE-611".to_string(),
                owasp_category: "A05:2021 – Security Misconfiguration".to_string(),
                languages: vec!["java".to_string()],
            },
            // C/C++-specific
            VulnerabilityPattern {
                id: "c-format-string".to_string(),
                name: "Format String Vulnerability".to_string(),
                pattern: Regex::new(r"(?i)(printf|sprintf|fprintf)\s*\([^,]*\)").unwrap(),
                category: "vulnerability".to_string(),
                severity: Severity::High,
                description: "Format string vulnerability detected".to_string(),
                recommendation: "Always use format specifiers with printf family functions".to_string(),
                cwe: "CWE-134".to_string(),
                owasp_category: "A03:2021 – Injection".to_string(),
                languages: vec!["c".to_string(), "cpp".to_string()],
            },
        ]);

        Self {
            cwe_patterns,
            owasp_patterns,
            language_specific_patterns,
        }
    }

    fn check_patterns(&self, source_file: &SourceFile, patterns: &[VulnerabilityPattern]) -> Result<Vec<Vulnerability>> {
        let mut vulnerabilities = Vec::new();
        let lines: Vec<&str> = source_file.content.lines().collect();
        let file_language = source_file.language.to_string().to_lowercase();

        for (line_index, line) in lines.iter().enumerate() {
            for pattern in patterns {
                // Check if pattern applies to this language
                if !pattern.languages.is_empty() && !pattern.languages.contains(&file_language) {
                    continue;
                }

                if let Some(captures) = pattern.pattern.captures(line) {
                    if let Some(matched) = captures.get(0) {
                        let vulnerability = create_vulnerability(
                            &pattern.id,
                            Some(&pattern.cwe),
                            &pattern.name,
                            pattern.severity.clone(),
                            &pattern.category,
                            &format!("{} - {}", pattern.description, pattern.owasp_category),
                            &source_file.path.to_string_lossy(),
                            line_index + 1,
                            matched.start(),
                            line.trim(),
                            &pattern.recommendation,
                        );
                        vulnerabilities.push(vulnerability);
                    }
                }
            }
        }

        Ok(vulnerabilities)
    }
}

impl RuleSet for VulnerabilityScannerRules {
    fn analyze(&self, source_file: &SourceFile, _ast: &ParsedAst) -> Result<Vec<Vulnerability>> {
        let mut vulnerabilities = Vec::new();

        // Check CWE patterns
        vulnerabilities.extend(self.check_patterns(source_file, &self.cwe_patterns)?);

        // Check OWASP patterns
        vulnerabilities.extend(self.check_patterns(source_file, &self.owasp_patterns)?);

        // Check language-specific patterns
        vulnerabilities.extend(self.check_patterns(source_file, &self.language_specific_patterns)?);

        Ok(vulnerabilities)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Language, parsers::SourceFile};
    use std::path::PathBuf;

    #[test]
    fn test_xss_detection() {
        let rules = VulnerabilityScannerRules::new();
        let source = SourceFile::new(
            PathBuf::from("test.js"),
            "element.innerHTML = userInput + '<div>'".to_string(),
            Language::Javascript,
        );
        let ast = crate::parsers::ParsedAst::new_source_only(source.content.clone());
        let vulnerabilities = rules.analyze(&source, &ast).unwrap();
        assert!(!vulnerabilities.is_empty());
        assert_eq!(vulnerabilities[0].id, "cwe-79-xss");
    }

    #[test]
    fn test_sql_injection_detection() {
        let rules = VulnerabilityScannerRules::new();
        let source = SourceFile::new(
            PathBuf::from("test.py"),
            "query = f\"SELECT * FROM users WHERE id = {user_id}\"".to_string(),
            Language::Python,
        );
        let ast = crate::parsers::ParsedAst::new_source_only(source.content.clone());
        let vulnerabilities = rules.analyze(&source, &ast).unwrap();
        assert!(!vulnerabilities.is_empty());
        assert_eq!(vulnerabilities[0].id, "cwe-89-sql-injection");
    }

    #[test]
    fn test_buffer_overflow_detection() {
        let rules = VulnerabilityScannerRules::new();
        let source = SourceFile::new(
            PathBuf::from("test.c"),
            "strcpy(buffer, user_input);".to_string(),
            Language::C,
        );
        let ast = crate::parsers::ParsedAst::new_source_only(source.content.clone());
        let vulnerabilities = rules.analyze(&source, &ast).unwrap();
        assert!(!vulnerabilities.is_empty());
        assert_eq!(vulnerabilities[0].id, "cwe-125-buffer-overflow");
    }

    #[test]
    fn test_prototype_pollution_detection() {
        let rules = VulnerabilityScannerRules::new();
        let source = SourceFile::new(
            PathBuf::from("test.js"),
            "obj[\"__proto__\"][\"polluted\"] = true;".to_string(),
            Language::Javascript,
        );
        let ast = crate::parsers::ParsedAst::new_source_only(source.content.clone());
        let vulnerabilities = rules.analyze(&source, &ast).unwrap();
        assert!(!vulnerabilities.is_empty());
        assert_eq!(vulnerabilities[0].id, "javascript-prototype-pollution");
    }
}